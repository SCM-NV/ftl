! Copyright (c) 2016, 2017  Robert RÃ¼ger
!
! This file is part of of the Fortran Template Library.
!
! The Fortran Template Library is free software: you can redistribute it and/or
! modify it under the terms of the GNU Lesser General Public License as
! published by the Free Software Foundation, either version 3 of the License, or
! (at your option) any later version.
!
! The Fortran Template Library is distributed in the hope that it will be
! useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
! General Public License for more details.
!
! You should have received a copy of the GNU Lesser General Public License along
! with the Fortran Template Library.  If not, see <http://www.gnu.org/licenses/>.


!   ftlAlgorithms
!   =============
!
! The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating)
! that operate on ranges of elements. Note that a range is defined as [first, last) where last refers to the element past
! the last element to inspect or modify.
!
! A range is any sequence of objects that can be accessed through iterators or pointers, such as an array or an instance
! of some of the FTL containers. Notice though, that algorithms operate through iterators directly on the values, not
! affecting in any way the structure of any possible container (it never affects the size or storage allocation of the
! container).

#ifdef FTL_INSTANTIATE_TEMPLATE

#if !defined(FTL_TEMPLATE_TYPE)
#error FTL_TEMPLATE_TYPE must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_TEMPLATE_TYPE_NAME)
#error FTL_TEMPLATE_TYPE_NAME must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_CONTAINER)
#error FTL_CONTAINER must be defined when instantiating ftlAlgorithms
#endif
#if !defined(FTL_CONTAINER_PROVIDES_FORWARD_ITERATOR)       && \
    !defined(FTL_CONTAINER_PROVIDES_BIDIRECTIONAL_ITERATOR) && \
    !defined(FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR)
#error FTL_CONTAINER_PROVIDES_*_INTERATOR must be defined when instantiating ftlAlgorithms
#endif

#include "ftlMacros.inc"

#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
#define FTL_TEMPLATE_TYPE_WRAP type(FTL_TEMPLATE_TYPE)
#else
#define FTL_TEMPLATE_TYPE_WRAP FTL_TEMPLATE_TYPE
#endif

#ifdef FTL_CONTAINER_IS_PLAIN_ARRAY
#define FTL_CONTAINER_TYPE FTL_TEMPLATE_TYPE_WRAP, dimension(:)
#else
#define FTL_CONTAINER_TYPE type(CAT(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME))
#endif

#define FTL_CONTAINER_ITERATOR_TYPE type(CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Iterator))


module CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,AlgorithmsModule)

#ifdef FTL_TEMPLATE_TYPE_MODULE
   use FTL_TEMPLATE_TYPE_MODULE
#endif
   use CAT3(FTL_CONTAINER,FTL_TEMPLATE_TYPE_NAME,Module)

   implicit none
   private


   ! =============> Non-modifying sequence operations:

   public :: ftlAllOf
   interface ftlAllOf
      module procedure ftlAllOfIteratorPair
      module procedure ftlAllOfContainer
   end interface

   public :: ftlAnyOf
   interface ftlAnyOf
      module procedure ftlAnyOfIteratorPair
      module procedure ftlAnyOfContainer
   end interface

   public :: ftlNoneOf
   interface ftlNoneOf
      module procedure ftlNoneOfIteratorPair
      module procedure ftlNoneOfContainer
   end interface

   public :: ftlForEach
   interface ftlForEach
      module procedure ftlForEachIteratorPair
      module procedure ftlForEachContainer
   end interface

   public :: ftlFind
   interface ftlFind
      module procedure ftlFindIteratorPair
      module procedure ftlFindContainer
   end interface

   public :: ftlFindIf
   interface ftlFindIf
      module procedure ftlFindIfIteratorPair
      module procedure ftlFindIfContainer
   end interface

   public :: ftlFindIfNot
   interface ftlFindIfNot
      module procedure ftlFindIfNotIteratorPair
      module procedure ftlFindIfNotContainer
   end interface

   ! TODO: ftlFindEnd

   public :: ftlFirstOf
   interface ftlFirstOf
      module procedure ftlFirstOfIteratorPair
      module procedure ftlFirstOfContainer
   end interface

   ! TODO: ftlAdjacentFind

   public :: ftlCount
   interface ftlCount
      module procedure ftlCountIteratorPair
      module procedure ftlCountContainer
   end interface

   public :: ftlCountIf
   interface ftlCountIf
      module procedure ftlCountIfIteratorPair
      module procedure ftlCountIfContainer
   end interface

   public :: ftlMismatch
   interface ftlMismatch
      module procedure ftlMismatchIterators
      module procedure ftlMismatchContainers
   end interface

   public :: ftlEqual
   interface ftlEqual
      module procedure ftlEqualIterators
      module procedure ftlEqualContainers
   end interface

   public :: ftlIsPermutation
   interface ftlIsPermutation
      module procedure ftlIsPermutationIterators
      module procedure ftlIsPermutationContainers
   end interface

   public :: ftlSearch
   interface ftlSearch
      module procedure ftlSearchIterators
      module procedure ftlSearchContainers
   end interface

   ! TODO: ftlSearchN


   ! =============> Modifying sequence operations:

   public :: ftlIterSwap
   interface ftlIterSwap
      module procedure ftlIterSwapPrivate
   end interface

   public :: ftlCopy
   interface ftlCopy
      module procedure ftlCopyIterators
      module procedure ftlCopyContainer
   end interface

   public :: ftlGenerate
   interface ftlGenerate
      module procedure ftlGenerateIterators
      module procedure ftlGenerateContainer
   end interface


   ! =============> Partitions:

   public :: ftlIsPartitioned
   interface ftlIsPartitioned
      module procedure ftlIsPartitionedIterators
      module procedure ftlIsPartitionedContainer
   end interface

   public :: ftlPartition
   interface ftlPartition
      module procedure ftlPartitionIterators
      module procedure ftlPartitionContainer
   end interface


   ! =============> Sorting operations:

   public :: ftlSort
   interface ftlSort
      module procedure ftlSortIterators
      module procedure ftlSortContainer
   end interface

   public :: ftlIsSorted
   interface ftlIsSorted
      module procedure ftlIsSortedIterators
      module procedure ftlIsSortedContainer
   end interface

   public :: ftlIsSortedUntil
   interface ftlIsSortedUntil
      module procedure ftlIsSortedUntilIterators
      module procedure ftlIsSortedUntilContainer
   end interface


   ! =============> Iterator operations:
   ! (in C++ these are in the <iterator> header, not in <algorithm>)

   public :: ftlIterCompare ! doesn't exist in C++ but is incredibly useful ...
   interface ftlIterCompare
      module procedure ftlIterComparePrivate
   end interface

   public :: ftlAdvance
   interface ftlAdvance
      module procedure ftlAdvancePrivate
   end interface

   public :: ftlDistance
   interface ftlDistance
      module procedure ftlDistancePrivate
   end interface


#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
   ! =============> Heap:

   public :: ftlMakeHeap
   interface ftlMakeHeap
      module procedure ftlMakeHeapIterators
      module procedure ftlMakeHeapContainer
   end interface

   public :: ftlPushHeap
   interface ftlPushHeap
      module procedure ftlPushHeapIterators
      module procedure ftlPushHeapContainer
   end interface

   public :: ftlPopHeap
   interface ftlPopHeap
      module procedure ftlPopHeapIterators
      module procedure ftlPopHeapContainer
   end interface

   public :: ftlIsHeap
   interface ftlIsHeap
      module procedure ftlIsHeapIterators
      module procedure ftlIsHeapContainer
   end interface

   public :: ftlIsHeapUntil
   interface ftlIsHeapUntil
      module procedure ftlIsHeapUntilIterators
      module procedure ftlIsHeapUntilContainer
   end interface
#endif


   ! =============> Interfaces for dummy procedures:

   abstract interface


      logical function UnaryPredicate(a)
#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
         import :: FTL_TEMPLATE_TYPE
#endif
         FTL_TEMPLATE_TYPE_WRAP, intent(in) :: a
      end function


      logical function Comparator(a, b)
#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
         import :: FTL_TEMPLATE_TYPE
#endif
         FTL_TEMPLATE_TYPE_WRAP, intent(in) :: a, b
      end function


      subroutine UnarySubroutine(a)
#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
         import :: FTL_TEMPLATE_TYPE
#endif
         FTL_TEMPLATE_TYPE_WRAP, intent(inout) :: a
      end subroutine


      FTL_TEMPLATE_TYPE_WRAP function Generator()
#ifdef FTL_TEMPLATE_TYPE_IS_DERIVED
         import :: FTL_TEMPLATE_TYPE
#endif
      end function


   end interface


contains



   ! =============> Non-modifying sequence operations:



   ! Returns true if pred returns true for all the elements in the range [first,last) or if the range is empty,
   ! and false otherwise.
   !
   logical function ftlAllOfIteratorPair(first, last, pred) result(alltrue)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred

      FTL_CONTAINER_ITERATOR_TYPE :: it

      alltrue = .true.
      it = first
      do while (it /= last)
         if (.not.pred(it%value)) then
            alltrue = .false.
            exit
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlAllOfContainer(container, pred) result(alltrue)
      FTL_CONTAINER_TYPE       , intent(in) :: container
      procedure(UnaryPredicate)             :: pred

      alltrue = ftlAllOfIteratorPair(Begin(container), End(container), pred)

   end function



   ! Returns true if pred returns true for any of the elements in the range [first,last), and false otherwise.
   !
   ! If [first,last) is an empty range, the function returns false.
   !
   logical function ftlAnyOfIteratorPair(first, last, pred) result(anytrue)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred

      FTL_CONTAINER_ITERATOR_TYPE :: it

      anytrue = .false.
      it = first
      do while (it /= last)
         if (pred(it%value)) then
            anytrue = .true.
            exit
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlAnyOfContainer(container, pred) result(anytrue)
      FTL_CONTAINER_TYPE       , intent(in) :: container
      procedure(UnaryPredicate)             :: pred

      anytrue = ftlAnyOfIteratorPair(Begin(container), End(container), pred)

   end function



   ! Returns true if pred returns false for all the elements in the range [first,last) or if the range is empty,
   ! and false otherwise.
   !
   logical function ftlNoneOfIteratorPair(first, last, pred) result(nonetrue)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred

      nonetrue = .not.ftlAnyOfIteratorPair(first, last, pred)

   end function
   !
   logical function ftlNoneOfContainer(container, pred) result(nonetrue)
      FTL_CONTAINER_TYPE       , intent(in) :: container
      procedure(UnaryPredicate)             :: pred

      nonetrue = .not.ftlAnyOfIteratorPair(Begin(container), End(container), pred)

   end function



   ! Calls subroutine subr on each of the elements in the range [first,last).
   !
   subroutine ftlForEachIteratorPair(first, last, subr)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnarySubroutine)              :: subr

      FTL_CONTAINER_ITERATOR_TYPE :: it

      it = first
      do while (it /= last)
         call subr(it%value)
         call it%Inc()
      enddo

   end subroutine
   !
   subroutine ftlForEachContainer(container, subr)
      FTL_CONTAINER_TYPE        , intent(in) :: container
      procedure(UnarySubroutine)             :: subr

      call ftlForEachIteratorPair(Begin(container), End(container), subr)

   end subroutine



   ! Returns an iterator to the first element in the range [first,last) that compares equal to val. If no such element is
   ! found, the function returns last.
   !
   ! The function uses operator== to compare the individual elements to val.
   !
   function ftlFindIteratorPair(first, last, val) result(it)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      FTL_TEMPLATE_TYPE_WRAP     , intent(in) :: val
      FTL_CONTAINER_ITERATOR_TYPE             :: it

      it = first
      do while (it /= last)
         if (it%value == val) exit
         call it%Inc()
      enddo

   end function
   !
   function ftlFindContainer(container, val) result(it)
      FTL_CONTAINER_TYPE         , intent(in) :: container
      FTL_TEMPLATE_TYPE_WRAP     , intent(in) :: val
      FTL_CONTAINER_ITERATOR_TYPE             :: it

      it = ftlFindIteratorPair(Begin(container), End(container), val)

   end function



   ! Returns an iterator to the first element in the range [first,last) for which pred returns true. If no such element is
   ! found, the function returns last.
   !
   function ftlFindIfIteratorPair(first, last, pred) result(it)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred
      FTL_CONTAINER_ITERATOR_TYPE             :: it

      it = first
      do while (it /= last)
         if (pred(it%value)) exit
         call it%Inc()
      enddo

   end function
   !
   function ftlFindIfContainer(container, pred) result(it)
      FTL_CONTAINER_TYPE         , intent(in) :: container
      procedure(UnaryPredicate)               :: pred
      FTL_CONTAINER_ITERATOR_TYPE             :: it

      it = ftlFindIfIteratorPair(Begin(container), End(container), pred)

   end function



   ! Returns an iterator to the first element in the range [first,last) for which pred returns false. If no such element
   ! is found, the function returns last.
   !
   function ftlFindIfNotIteratorPair(first, last, pred) result(it)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred
      FTL_CONTAINER_ITERATOR_TYPE             :: it

      it = first
      do while (it /= last)
         if (.not.pred(it%value)) exit
         call it%Inc()
      enddo

   end function
   !
   function ftlFindIfNotContainer(container, pred) result(it)
      FTL_CONTAINER_TYPE         , intent(in) :: container
      procedure(UnaryPredicate)               :: pred
      FTL_CONTAINER_ITERATOR_TYPE             :: it

      it = ftlFindIfNotIteratorPair(Begin(container), End(container), pred)

   end function



   ! Returns an iterator to the first element in the range [first1,last1) that matches any of the elements in [first2,last2).
   ! If no such element is found, the function returns last1.
   !
   ! The elements in [first1,last1) are sequentially compared to each of the values in [first2,last2) using operator== (or
   ! comp, if present), until a pair matches.
   !
   function ftlFirstOfIteratorPair(first1, last1, first2, last2, comp) result(firstOf)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first1, last1, first2, last2
      procedure(Comparator)      , optional   :: comp
      FTL_CONTAINER_ITERATOR_TYPE             :: firstOf

      FTL_CONTAINER_ITERATOR_TYPE :: it

      if (first2 == last2) then
         firstOf = last1
         return
      endif

      firstOf = first1
      do while (firstOf /= last1)
         it = first2
         do while (it /= last2)
            if (present(comp)) then
               if (comp(firstOf%value, it%value)) return
            else
               if (firstOf%value == it%value) return
            endif
            call it%Inc()
         enddo
         call firstOf%Inc()
      enddo

   end function
   !
   function ftlFirstOfContainer(container1, container2, comp) result(firstOf)
      FTL_CONTAINER_TYPE         , intent(in) :: container1, container2
      procedure(Comparator)      , optional   :: comp
      FTL_CONTAINER_ITERATOR_TYPE             :: firstOf

      firstOf = ftlFirstOfIteratorPair(Begin(container1), End(container1), Begin(container2), End(container2), comp)

   end function


   ! Returns the number of elements in the range [first,last) that compare equal to val.
   !
   ! The function uses the == operator to compare the individual elements to val.
   !
   integer function ftlCountIteratorPair(first, last, val) result(num)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      FTL_TEMPLATE_TYPE_WRAP     , intent(in) :: val

      FTL_CONTAINER_ITERATOR_TYPE :: it

      num = 0
      it = first
      do while (it /= last)
         if (it%value == val) num = num + 1
         call it%Inc()
      enddo

   end function
   !
   integer function ftlCountContainer(container, val) result(num)
      FTL_CONTAINER_TYPE    , intent(in) :: container
      FTL_TEMPLATE_TYPE_WRAP, intent(in) :: val

      num = ftlCountIteratorPair(Begin(container), End(container), val)

   end function



   ! Returns the number of elements in the range [first,last) for which pred is true.
   !
   integer function ftlCountIfIteratorPair(first, last, pred) result(num)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred

      FTL_CONTAINER_ITERATOR_TYPE :: it

      num = 0
      it = first
      do while (it /= last)
         if (pred(it%value)) num = num + 1
         call it%Inc()
      enddo

   end function
   !
   integer function ftlCountIfContainer(container, pred) result(num)
      FTL_CONTAINER_TYPE       , intent(in) :: container
      procedure(UnaryPredicate)             :: pred

      num = ftlCountIfIteratorPair(Begin(container), End(container), pred)

   end function



   ! Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns the
   ! first element of both sequences that does not match.
   !
   ! The elements are compared using operator== or comp (if present).
   !
   ! The function returns a pair of iterators to the first element in each range that does not match.
   !
   function ftlMismatchIterators(first1, last1, first2, comp) result(it)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first1, last1, first2
      procedure(Comparator)      , optional   :: comp
      FTL_CONTAINER_ITERATOR_TYPE             :: it(2)

      it(1) = first1
      it(2) = first2
      do while (it(1) /= last1)
         if (present(comp)) then
            if (.not.comp(it(1)%value,it(2)%value)) exit
         else
            if (.not.(it(1)%value == it(2)%value)) exit
         endif
         call it(1)%Inc()
         call it(2)%Inc()
      enddo

   end function
   !
   function ftlMismatchContainers(container1, container2, comp) result(it)
      FTL_CONTAINER_TYPE         , intent(in) :: container1, container2
      procedure(Comparator)      , optional   :: comp
      FTL_CONTAINER_ITERATOR_TYPE             :: it(2)

      it = ftlMismatchIterators(Begin(container1), End(container1), Begin(container2), comp)

   end function



   ! Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns true if all
   ! of the elements in both ranges match.
   !
   ! The elements are compared using operator== (or comp, if present).
   !
   logical function ftlEqualIterators(first1, last1, first2, comp) result(equal)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first1, last1, first2
      procedure(Comparator)      , optional   :: comp

      FTL_CONTAINER_ITERATOR_TYPE :: it1, it2

      equal = .true.
      it1 = first1
      it2 = first2

      do while (it1 /= last1)
         if (present(comp)) then
            equal = comp(it1%value, it2%value)
         else
            equal = (it1%value == it2%value)
         endif
         if (.not.equal) return
         call it1%Inc()
         call it2%Inc()
      enddo

   end function
   !
   logical function ftlEqualContainers(container1, container2, comp) result(equal)
      FTL_CONTAINER_TYPE   , intent(in) :: container1, container2
      procedure(Comparator), optional   :: comp

      if (Size(container1) /= Size(container2)) then
         equal = .false.
      else
         equal = ftlEqualIterators(Begin(container1), End(container1), Begin(container2), comp)
      endif

   end function



   ! Compares the elements in the range [first1,last1) with those in the range beginning at first2, and returns true if all of the
   ! elements in both ranges match, even in a different order.
   !
   ! The elements are compared using operator==.
   !
   logical function ftlIsPermutationIterators(first1, last1, first2) result(isPermutation)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first1, last1, first2

      FTL_CONTAINER_ITERATOR_TYPE :: firstdiff(2), last2, it1
      integer :: n

      isPermutation = .true.

      ! check if sequences are identical or at least have a common beginning (which we would ignore later)
      firstdiff = ftlMismatchIterators(first1, last1, first2)
      if (firstdiff(1) == last1) return

      ! get an iterator to the end of range 2
      last2 = firstdiff(2)
      last2 = ftlAdvance(last2, ftlDistance(firstdiff(1), last1))

      it1 = firstdiff(1)
      do while (it1 /= last1)

         if (ftlFind(firstdiff(1), it1, it1%value) == it1) then ! this is the first time we see it1%value
            n = ftlCount(firstdiff(2), last2, it1%value)
            if (n == 0) then ! it1%value is not anywhere in range 2
               isPermutation = .false.
               return
            endif
            if (n /= ftlCount(firstdiff(1), last1, it1%value)) then ! count of it1%value is different in range 1 and range 2
               isPermutation = .false.
               return
            endif
         endif

         call it1%Inc()
      enddo

   end function
   !
   logical function ftlIsPermutationContainers(container1, container2) result(isPermutation)
      FTL_CONTAINER_TYPE, intent(in) :: container1, container2

      if (Size(container1) /= Size(container2)) then
         isPermutation = .false.
      else
         isPermutation = ftlIsPermutationIterators(Begin(container1), End(container1), Begin(container2))
      endif

   end function



   ! Searches the range [first1,last1) for the first occurrence of the sequence defined by [first2,last2), and returns an
   ! iterator to its first element, or last1 if no occurrences are found.
   !
   ! The elements in both ranges are compared sequentially using operator== (or comp, if present): A subsequence of
   ! [first1,last1) is considered a match only when this is true for _all_ the elements of [first2,last2).
   !
   ! This function returns the first of such occurrences. For an algorithm that returns the last instead, see ftlFindEnd.
   !
   function ftlSearchIterators(first1, last1, first2, last2, comp) result(itFirst)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first1, last1, first2, last2
      procedure(Comparator)      , optional   :: comp
      FTL_CONTAINER_ITERATOR_TYPE             :: itFirst

      FTL_CONTAINER_ITERATOR_TYPE :: it1, it2

      itFirst = first1
      if (first2 == last2) return ! specified by C++11

      do while (itFirst /= last1)
         it1 = itFirst
         it2 = first2
         do while (.true.)
            if (present(comp)) then
               if (.not.comp(it1%value, it2%value)) exit
            else
               if (.not.(it1%value == it2%value)) exit
            endif
            call it1%Inc()
            call it2%Inc()
            if (it2 == last2) return ! complete sequence found
            if (it1 == last1) then ! at the end of [first1,last1) but [first2,last2) sequence not complete yet
               itFirst = last1
               return
            endif
         enddo
         call itFirst%Inc()
      enddo

   end function
   !
   function ftlSearchContainers(container1, container2, comp) result(itFirst)
      FTL_CONTAINER_TYPE         , intent(in) :: container1, container2
      procedure(Comparator)      , optional   :: comp
      FTL_CONTAINER_ITERATOR_TYPE             :: itFirst

      if (Size(container1) < Size(container2)) then
         itFirst = End(container1)
      else
         itFirst = ftlSearchIterators(Begin(container1), End(container1), Begin(container2), End(container2), comp)
      endif

   end function



   ! =============> Modifying sequence operations:



   ! Swaps the elements pointed to by a and b.
   !
   subroutine ftlIterSwapPrivate(it1, it2)
      FTL_CONTAINER_ITERATOR_TYPE :: it1, it2

      FTL_TEMPLATE_TYPE_WRAP :: tmp

#ifdef FTL_TEMPLATE_TYPE_PROVIDES_FTLMOVE
      call ftlMove(it1%value, tmp)
      call ftlMove(it2%value, it1%value)
      call ftlMove(tmp,it2%value)
#else
      tmp = it1%value
      it1%value = it2%value
      it2%value = tmp
#endif
   end subroutine



   ! Copies the elements in the range [first,last) into the range beginning at dest.
   !
   ! The function returns an iterator to the end of the destination range (which points to the element following the last
   ! element copied).
   !
   ! The ranges shall not overlap in such a way that dest points to an element in the range [first,last). For such cases,
   ! see ftlCopyBackward.
   !
   function ftlCopyIterators(first, last, dest) result(writer)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last, dest
      FTL_CONTAINER_ITERATOR_TYPE             :: writer

      FTL_CONTAINER_ITERATOR_TYPE :: reader

      reader = first
      writer = dest
      do while (reader /= last)
         writer%value = reader%value
         call reader%Inc()
         call writer%Inc()
      enddo

   end function
   !
   function ftlCopyContainer(container, dest) result(writer)
      FTL_CONTAINER_TYPE         , intent(in) :: container
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: dest
      FTL_CONTAINER_ITERATOR_TYPE             :: writer

      writer = ftlCopyIterators(Begin(container), End(container), dest)

   end function



   ! Assigns the value returned by successive calls to gen to the elements in the range [first,last).
   !
   subroutine ftlGenerateIterators(first, last, gen)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(Generator)                    :: gen

      FTL_CONTAINER_ITERATOR_TYPE :: it

      it = first
      do while (it /= last)
         it%value = gen()
         call it%Inc()
      enddo

   end subroutine
   !
   subroutine ftlGenerateContainer(container, gen)
      FTL_CONTAINER_TYPE  , intent(in) :: container
      procedure(Generator)             :: gen

      call ftlGenerateIterators(Begin(container), End(container), gen)

   end subroutine



   ! =============> Partitions:



   ! Rearranges the elements from the range [first,last), in such a way that all the elements for which pred returns true
   ! precede all those for which it returns false. The iterator returned points to the first element of the second group.
   !
   ! The relative ordering within each group is not necessarily the same as before the call. See stable_partition for a
   ! function with a similar behavior but with stable ordering within each group.
   !
   function ftlPartitionIterators(first, last, pred) result(pivot)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred
      FTL_CONTAINER_ITERATOR_TYPE             :: pivot

      FTL_CONTAINER_ITERATOR_TYPE :: itRev

      ! TODO: implementation for forward iterators

      pivot = first
      itRev = last
      do while (pivot /= itRev)
         do while (pred(pivot%value))
            call pivot%Inc()
            if (pivot == itRev) return
         enddo
         do while (.true.)
            call itRev%Dec()
            if (pivot == itRev) return
            if (pred(itRev%value)) exit
         enddo
         call ftlIterSwap(pivot,itRev)
         call pivot%Inc()
      enddo

   end function
   !
   function ftlPartitionContainer(container, pred) result(pivot)
      FTL_CONTAINER_TYPE         , intent(in) :: container
      procedure(UnaryPredicate)               :: pred
      FTL_CONTAINER_ITERATOR_TYPE             :: pivot

      pivot = ftlPartitionIterators(Begin(container), End(container), pred)

   end function



   ! Returns true if all the elements in the range [first,last) for which pred returns true precede those for which it
   ! returns false.
   !
   ! If the range is empty, the function returns true.
   !
   logical function ftlIsPartitionedIterators(first, last, pred) result(isPartitioned)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
      procedure(UnaryPredicate)               :: pred

      FTL_CONTAINER_ITERATOR_TYPE :: it

      isPartitioned = .true.
      it = first
      do while (it /= last)
         if (pred(it%value)) then
            call it%Inc()
         else
            exit
         endif
      enddo
      do while (it /= last)
         if (pred(it%value)) then
            isPartitioned = .false.
            return
         endif
         call it%Inc()
      enddo

   end function
   !
   logical function ftlIsPartitionedContainer(container, pred) result(isPartitioned)
      FTL_CONTAINER_TYPE       , intent(in) :: container
      procedure(UnaryPredicate)             :: pred

      isPartitioned = ftlIsPartitionedIterators(Begin(container), End(container), pred)

   end function



   ! =============> Sorting operations:



   ! Sorts the elements in the range [first,last) into ascending order.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   ! Equivalent elements are not guaranteed to keep their original relative order (see stable_sort).
   !
   subroutine ftlSortIterators(first, last, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      if (first == last) return

#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
      if (last-first < 128) then
         call InsertionSort(first, last, comp)
      else
         call IntroSort(first, last, comp, 2*floor(log(float(last-first))/log(2.0)))
      endif
#else /* ifdef FTL_CONTAINER_PROVIDES_BIDIRECTIONAL_ITERATOR || ifdef FTL_CONTAINER_PROVIDES_FORWARD_ITERATOR */
      ! TODO: implement an O(N*log(N)) algorithm
      call InsertionSort(first, last, comp)
#endif
   end subroutine
   !
   subroutine ftlSortContainer(container, comp)
      FTL_CONTAINER_TYPE   , intent(inout) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional      :: comp
#else
      procedure(Comparator)                :: comp
#endif

      call ftlSortIterators(Begin(container), End(container), comp)

   end subroutine



   ! Internally used sorting algorithms:
   !
   !
   subroutine InsertionSort(first, last, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      FTL_CONTAINER_ITERATOR_TYPE :: sortedUntil, insertAt, insertAtMinus1
      FTL_TEMPLATE_TYPE_WRAP :: value
      logical :: shift

      if (first == last) return

      sortedUntil = ftlIsSortedUntil(first, last, comp)
      do while (sortedUntil /= last)
         value = sortedUntil%value
         insertAt = sortedUntil
         call insertAt%Dec()
         sortedUntil%value = insertAt%value
         do while (insertAt /= first)
            insertAtMinus1 = insertAt
            call insertAtMinus1%Dec()
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
            if (present(comp)) then
               shift = .not.comp(insertAtMinus1%value, value)
            else
               shift = .not.(insertAtMinus1%value < value)
            endif
#else
            shift = .not.comp(insertAtMinus1%value, value)
#endif
            if (shift) then
               insertAt%value = insertAtMinus1%value
               call insertAt%Dec()
            else
               exit
            endif
         enddo
         insertAt%value = value
         sortedUntil = ftlIsSortedUntil(sortedUntil, last, comp)
      enddo

   end subroutine
   !
#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
   subroutine HeapSort(first, last, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      FTL_CONTAINER_ITERATOR_TYPE :: endOfHeap

      if (first == last) return

      call ftlMakeHeap(first, last, comp)
      endOfHeap = last
      do while (endOfHeap - first > 128)
         call ftlPopHeapIterators(first, endOfHeap, comp)
         call endOfHeap%Dec()
      enddo
      call InsertionSort(first, last, comp)

   end subroutine
   !
   recursive subroutine IntroSort(first, last, comp, depthLimit)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif
      integer                    , intent(in) :: depthLimit

      FTL_CONTAINER_ITERATOR_TYPE :: pivot, it1, it2

      if (first == last) then
         return
      else if (last - first <= 128) then
         call InsertionSort(first, last, comp)
      else if (depthLimit == 0) then
         call HeapSort(first, last, comp)
      else
         pivot = last - 1

         associate (middle => it1)
         ! median of 3 pivoting
         middle = first + (last-first)/2
         if (ftlIterCompare(middle,first,comp)) then
            call ftlIterSwap(middle,first)
         endif
         if (ftlIterCompare(middle,pivot,comp)) then
            call ftlIterSwap(middle,pivot)
         else if (ftlIterCompare(pivot,first,comp)) then
            call ftlIterSwap(pivot,first)
         endif
         ! first = smallest, middle = largest, pivot = last-1 = median
         end associate

         associate (left => it1, right => it2)

         ! partitioning:
         left = first
         right = pivot-1
         do while (left /= right)
            if (ftlIterCompare(left,pivot,comp)) then
               call left%Inc()
            else
               do while (left /= right)
                  if (.not.ftlIterCompare(right,pivot,comp)) then
                     call right%Dec()
                  else
                     exit
                  endif
               enddo
               call ftlIterSwap(left,right)
            endif
         enddo
         call ftlIterSwap(pivot, right) ! swap pivot to its correct place at right

         ! recursion:
         call IntroSort(first, right, comp, depthLimit-1) ! introsort left subrange
         call IntroSort(right+1, last, comp, depthLimit-1) ! ... and right subrange

         end associate

      endif

   end subroutine
#endif /* ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR */



   ! Returns true if the range [first,last) is sorted into ascending order.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   logical function ftlIsSortedIterators(first, last, comp) result(isSorted)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      isSorted = (ftlIsSortedUntilIterators(first, last, comp) == last)

   end function
   !
   logical function ftlIsSortedContainer(container, comp) result(isSorted)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif

      isSorted = ftlIsSortedIterators(Begin(container), End(container), comp)

   end function



   ! Returns an iterator to the first element in the range [first,last) which does not follow an ascending order.
   !
   ! The range between first and the iterator returned is sorted.
   !
   ! If the entire range is sorted, the function returns last.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   function ftlIsSortedUntilIterators(first, last, comp) result(firstUnsorted)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif
      FTL_CONTAINER_ITERATOR_TYPE             :: firstUnsorted

      FTL_CONTAINER_ITERATOR_TYPE :: lastSorted

      firstUnsorted = first
      if (first == last) return

      lastSorted = first
      call firstUnsorted%Inc()
      do while (firstUnsorted /= last)
         if (ftlIterCompare(firstUnsorted, lastSorted, comp)) return
         call firstUnsorted%Inc()
         call lastSorted%Inc()
      enddo

   end function
   !
   function ftlIsSortedUntilContainer(container, comp) result(firstUnsorted)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif
      FTL_CONTAINER_ITERATOR_TYPE   :: firstUnsorted

      firstUnsorted = ftlIsSortedUntilIterators(Begin(container), End(container), comp)

   end function



   ! =============> Iterator operations:



   logical function ftlIterComparePrivate(it1, it2, comp) result(iterCompare)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: it1, it2
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp

      if (present(comp)) then
         iterCompare = comp(it1%value, it2%value)
      else
         iterCompare = (it1%value < it2%value)
      endif
#else
      procedure(Comparator)                                                 :: comp

      iterCompare = comp(it1%value, it2%value)
#endif
   end function



   function ftlAdvancePrivate(itin, n) result(itout)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: itin
      integer                    , intent(in) :: n
      FTL_CONTAINER_ITERATOR_TYPE             :: itout

#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
      itout = itin + n
#else
      integer :: i

      itout = itin
      do i = 1, n
         call itout%Inc()
      enddo
#endif

   end function



   integer function ftlDistancePrivate(it1, it2) result(dist)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: it1, it2

#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
      dist = it2 - it1
#else
      FTL_CONTAINER_ITERATOR_TYPE :: it

      dist = 0
      it = it1
      do while (it /= it2)
         dist = dist + 1
         call it%Inc()
      enddo
#endif

   end function



#ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR
   ! =============> Heap:



   ! Rearranges the elements in the range [first,last) in such a way that they form a heap.
   !
   ! A heap is a way to organize the elements of a range that allows for fast retrieval of the element with the highest
   ! value at any moment (with pop_heap), even repeatedly, while allowing for fast insertion of new elements (with
   ! push_heap).
   !
   ! The element with the highest value is always pointed by first. The order of the other elements depends on the
   ! particular implementation, but it is consistent throughout all heap-related functions of this header.
   !
   ! The elements are compared using operator< (if available), or comp (if present): The element with the
   ! highest value is an element for which this would return false when compared to every other element in the range.
   !
   ! The standard container adaptor priority_queue calls make_heap, push_heap and pop_heap automatically to maintain heap
   ! properties for a container.
   !
   ! The elements are compared using operator< (if available, this would produce a max-heap), or comp (if present).
   !
   subroutine ftlMakeHeapIterators(first, last, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      FTL_CONTAINER_ITERATOR_TYPE :: it

      it = first + (last-first) / 2
      do while (.true.)
         call HeapDown(first, last, it, comp)
         if (it == first) exit
         call it%Dec()
      enddo

   end subroutine
   !
   subroutine ftlMakeHeapContainer(container, comp)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif

      call ftlMakeHeapIterators(Begin(container), End(container), comp)

   end subroutine



   ! Given a heap in the range [first,last-1), this function extends the range considered a heap to [first,last) by placing
   ! the value in (last-1) into its corresponding location within it.
   !
   ! A range can be organized into a heap by calling make_heap. After that, its heap properties are preserved if elements are
   ! added and removed from it using push_heap and pop_heap, respectively.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   subroutine ftlPushHeapIterators(first, last, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      call HeapUpDown(first, last, last-1, comp)

   end subroutine
   !
   subroutine ftlPushHeapContainer(container, comp)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif

      call ftlPushHeapIterators(Begin(container), End(container), comp)

   end subroutine



   ! Rearranges the elements in the heap range [first,last) in such a way that the part considered a heap is shortened by
   ! one: The element with the highest value is moved to (last-1).
   !
   ! While the element with the highest value is moved from first to (last-1) (which now is out of the heap), the other
   ! elements are reorganized in such a way that the range [first,last-1) preserves the properties of a heap.
   !
   ! A range can be organized into a heap by calling make_heap. After that, its heap properties are preserved if elements are
   ! added and removed from it using push_heap and pop_heap, respectively.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   subroutine ftlPopHeapIterators(first, last, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      call ftlIterSwap(first, last-1)
      call HeapDown(first, last-1, first, comp)

   end subroutine
   !
   subroutine ftlPopHeapContainer(container, comp)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif

      call ftlPopHeapIterators(Begin(container), End(container), comp)

   end subroutine



   ! Internal heap helper methods
   !
   subroutine HeapDown(first, last, downIn, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last, downIn
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      FTL_CONTAINER_ITERATOR_TYPE :: down, leftChild, rightChild, largerChild

      down = downIn
      do while (.true.)

         leftChild = first + (down-first)*2 + 1
         if (leftChild >= last) exit ! node is all the way at the bottom, we are done
         largerChild = leftChild

         rightChild = leftChild + 1
         if (rightChild < last) then
            if (ftlIterCompare(leftChild, rightChild, comp)) largerChild = rightChild
         endif

         if (ftlIterCompare(down, largerChild, comp)) then
            call ftlIterSwap(down, largerChild)
            down = largerChild
         else
            exit
         endif

      enddo

   end subroutine
   !
   subroutine HeapUpDown(first, last, upIn, comp)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last, upIn
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      FTL_CONTAINER_ITERATOR_TYPE :: up, parent

      up = UpIn
      do while (up /= first)
         parent = first + (up-first-1)/2
         if (ftlIterCompare(up, parent, comp)) exit
         call ftlIterSwap(up, parent)
         up = parent
      enddo
      call HeapDown(first, last, up, comp)

   end subroutine



   ! Returns true if the range [first,last) forms a heap, as if constructed with make_heap.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   logical function ftlIsHeapIterators(first, last, comp) result(isHeap)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif

      isHeap = (ftlIsHeapUntilIterators(first, last, comp) == last)

   end function
   !
   logical function ftlIsHeapContainer(container, comp) result(isHeap)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif

      isHeap = ftlIsHeapIterators(Begin(container), End(container), comp)

   end function



   ! Returns an iterator to the first element in the range [first,last) which is not in a valid position if the range is
   ! considered a heap (as if constructed with make_heap).
   !
   ! The range between first and the iterator returned is a heap.
   !
   ! If the entire range is a valid heap, the function returns last.
   !
   ! The elements are compared using operator< (if available), or comp (if present).
   !
   function ftlIsHeapUntilIterators(first, last, comp) result(heapUntil)
      FTL_CONTAINER_ITERATOR_TYPE, intent(in) :: first, last
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator)      , optional   :: comp
#else
      procedure(Comparator)                   :: comp
#endif
      FTL_CONTAINER_ITERATOR_TYPE :: heapUntil

      FTL_CONTAINER_ITERATOR_TYPE :: parent

      heapUntil = first
      do while (heapUntil /= last)
         parent = first + (heapUntil-first-1)/2
         if (ftlIterCompare(parent, heapUntil, comp)) return
         call heapUntil%Inc()
      enddo

   end function
   !
   function ftlIsHeapUntilContainer(container, comp) result(heapUntil)
      FTL_CONTAINER_TYPE   , intent(in) :: container
#ifdef FTL_TEMPLATE_TYPE_PROVIDES_COMPARATOR_SMALLER
      procedure(Comparator), optional   :: comp
#else
      procedure(Comparator)             :: comp
#endif
      FTL_CONTAINER_ITERATOR_TYPE :: heapUntil

      heapUntil = ftlIsHeapUntilIterators(Begin(container), End(container), comp)

   end function

#endif /* ifdef FTL_CONTAINER_PROVIDES_RANDOM_ACCESS_ITERATOR */


end module
#endif
